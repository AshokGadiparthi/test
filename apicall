Perfect üëç ‚Äî you‚Äôre using the **`serlesen/fullstack-oauth2`** pattern, which was designed for validating tokens from an external provider (Google) ‚Äî *not* for redirect-based sign-in.

Right now your backend is configured as a **Resource Server** (`opaqueToken`), meaning it expects the Angular app to already have a valid access token and simply validates it.
If you actually want **browser login with redirect ‚Üí Google SSO ‚Üí Spring Boot ‚Üí Angular**, you need to change it from ‚Äúresource server‚Äù mode to ‚Äúclient login‚Äù mode.

Below I‚Äôll show you the step-by-step changes class by class.

---

## üîß 1Ô∏è‚É£ `SecurityConfig.java` ‚Üí convert from Resource Server to OAuth 2 Login

### Before

```java
.oauth2ResourceServer(c -> c.opaqueToken(Customizer.withDefaults()));
```

### After

```java
.oauth2Login(oauth -> oauth
        .defaultSuccessUrl("http://localhost:4200/home", true)
)
.logout(logout -> logout
        .logoutSuccessUrl("http://localhost:4200/")
);
```

Also change the session policy: for a login flow you can keep stateless = true if you use JWT cookies, but normally use default (STATEFUL) first.

Full class:

```java
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .cors(Customizer.withDefaults())
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/", "/error", "/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2Login(oauth -> oauth
                .defaultSuccessUrl("http://localhost:4200/home", true)
            )
            .logout(logout -> logout
                .logoutSuccessUrl("http://localhost:4200/")
            );
        return http.build();
    }
}
```

‚úÖ Remove the `userInfoClient` injection and all `OpaqueTokenIntrospector` bits ‚Äî they are not needed anymore.

---

## üîß 2Ô∏è‚É£ `WebConfig.java`

Keep as is ‚Äî your CORS config looks good, but allow credentials if you‚Äôll use cookies:

```java
registry.addMapping("/**")
        .allowedMethods("GET", "POST", "OPTIONS")
        .allowedOrigins("http://localhost:4200")
        .allowCredentials(true);
```

---

## üîß 3Ô∏è‚É£ `WebClientConfig.java`

You can **delete this class entirely** for the login flow.
It‚Äôs only needed for token introspection (resource server).
After switching to OAuth2 login, Spring Security will automatically call Google‚Äôs user-info endpoint via its own client.

---

## üîß 4Ô∏è‚É£ `GoogleOpaqueTokenIntrospector.java`

Also **delete this class** ‚Äî not used anymore.
OAuth2 Login handles token exchange and user info automatically.

---

## ‚úÖ Add/Update `application.yml`

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: YOUR_CLIENT_ID
            client-secret: YOUR_CLIENT_SECRET
            scope:
              - openid
              - email
              - profile
            redirect-uri: "{baseUrl}/login/oauth2/code/google"
        provider:
          google:
            authorization-uri: https://accounts.google.com/o/oauth2/v2/auth
            token-uri: https://oauth2.googleapis.com/token
            user-info-uri: https://www.googleapis.com/oauth2/v3/userinfo
            user-name-attribute: sub
```

---

## ‚úÖ Final flow

1. Angular sends browser to
   `http://localhost:8080/oauth2/authorization/google`
2. Google login page appears ‚Üí user signs in.
3. Google redirects back to
   `http://localhost:8080/login/oauth2/code/google`
4. Spring Boot exchanges the code for token and authenticates.
5. User is redirected to `http://localhost:4200/home`.

---

Would you like me to show how to return the logged-in user‚Äôs details (email, name) to your Angular app after login?
