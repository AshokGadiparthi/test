dbClient.readWriteTransaction().run(transaction -> {
    Map<String, String> uuidCache = new HashMap<>();  // ✅ Local cache for storing UUIDs per `cust_id, acct_no`
    Map<String, Timestamp> insertTsCache = new HashMap<>(); // ✅ Cache for insert_ts per `cust_id, acct_no`

    for (TransactionMessage msg : sortedMessages) {
        String businessKey = msg.getCustId() + "_" + msg.getAcctNo();

        String existingUUID = uuidCache.get(businessKey);
        Timestamp existingInsertTs = insertTsCache.get(businessKey);

        // ✅ Perform lookup if UUID is not cached yet
        if (existingUUID == null) {
            Statement statement = Statement.newBuilder(
                "SELECT UUID, insert_ts FROM YourTable WHERE cust_id = @cust_id AND acct_no = @acct_no")
                .bind("cust_id").to(msg.getCustId())
                .bind("acct_no").to(msg.getAcctNo())
                .build();

            try (ResultSet resultSet = transaction.executeQuery(statement)) {
                if (resultSet.next()) {
                    existingUUID = resultSet.getString("UUID");  // ✅ Reuse existing UUID
                    existingInsertTs = resultSet.getTimestamp("insert_ts");
                }
            }

            // ✅ If UUID is still null, generate a new one
            if (existingUUID == null) {
                existingUUID = UUID.randomUUID().toString();
                existingInsertTs = Timestamp.now(); // ✅ Set insert_ts for first insert
            }

            // ✅ Store in local cache to reuse in the same transaction
            uuidCache.put(businessKey, existingUUID);
            insertTsCache.put(businessKey, existingInsertTs);
        }

        Timestamp updateTs = Timestamp.now();  // ✅ Always set update_ts for every record

        // ✅ Insert or update record
        Mutation.WriteBuilder mutationBuilder = Mutation.newInsertOrUpdateBuilder("YourTable")
            .set("cust_id").to(msg.getCustId())
            .set("acct_no").to(msg.getAcctNo())
            .set("payload").to(msg.getPayload())
            .set("ops_ts").to(Timestamp.now())
            .set("UUID").to(existingUUID);

        if (!insertTsCache.containsKey(businessKey)) {
            mutationBuilder.set("insert_ts").to(existingInsertTs);
            insertTsCache.put(businessKey, existingInsertTs);  // ✅ Ensure insert_ts is only set once
        } else {
            mutationBuilder.set("update_ts").to(updateTs);
        }

        transaction.buffer(mutationBuilder.build());  // ✅ Buffer the mutation for transaction
    }

    return null;  // ✅ Commits all changes at once
});
