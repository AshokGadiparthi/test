import com.google.cloud.pubsub.v1.Publisher;
import com.google.protobuf.ByteString;
import com.google.pubsub.v1.PubsubMessage;
import com.google.pubsub.v1.TopicName;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.ExecutionException;

public class PubSubMessagePublisher {

    public static void main(String[] args) throws IOException, ExecutionException, InterruptedException {
        // Define Pub/Sub topic details
        String projectId = "your-project-id";  // Update with your project ID
        String topicId = "your-topic-id";  // Update with your topic ID

        // Create Pub/Sub publisher
        TopicName topicName = TopicName.of(projectId, topicId);
        Publisher publisher = null;

        try {
            publisher = Publisher.newBuilder(topicName).build();

            // Generate and publish 1 million messages
            String tableName = "SpannerToPubSubCDC";
            String[] columns = {"cust_id", "acct_num", "selected_MTN", "mtn", "order_num"};

            // Generate SQL statements
            List<String> inserts = generateInsertStatements(tableName, columns, 1000000);
            List<String> updates = generateUpdateStatements(tableName, columns, inserts, 800000);
            List<String> deletes = generateDeleteStatements(tableName, inserts, 500000);

            // Publish the SQL statements as Pub/Sub messages
            publishMessages(publisher, inserts);
            publishMessages(publisher, updates);
            publishMessages(publisher, deletes);

        } finally {
            if (publisher != null) {
                publisher.shutdown();
            }
        }
    }

    private static void publishMessages(Publisher publisher, List<String> messages) throws ExecutionException, InterruptedException {
        for (String message : messages) {
            ByteString data = ByteString.copyFromUtf8(message);
            PubsubMessage pubsubMessage = PubsubMessage.newBuilder().setData(data).build();
            publisher.publish(pubsubMessage).get();
        }
    }

    private static List<String> generateInsertStatements(String tableName, String[] columns, int count) {
        Random random = new Random();
        List<String> insertStatements = new ArrayList<>();

        for (int i = 1; i <= count; i++) {
            String cust_id = String.valueOf(i);
            String acct_num = String.valueOf(100000 + random.nextInt(900000));
            String selected_MTN = String.valueOf(5000000000L + random.nextInt(999999999));
            String mtn = String.valueOf(5000000000L + random.nextInt(999999999));
            String order_num = String.valueOf(200000 + random.nextInt(900000));

            String sql = String.format("INSERT INTO %s (%s) VALUES ('%s', '%s', '%s', '%s', '%s');",
                    tableName, String.join(", ", columns), cust_id, acct_num, selected_MTN, mtn, order_num);
            insertStatements.add(sql);
        }
        return insertStatements;
    }

    private static List<String> generateUpdateStatements(String tableName, String[] columns, List<String> inserts, int count) {
        Random random = new Random();
        List<String> updateStatements = new ArrayList<>();
        List<String> randomInserts = new ArrayList<>(inserts.subList(0, count));

        for (String insert : randomInserts) {
            String cust_id = extractCustIdFromInsert(insert);
            String new_selected_MTN = String.valueOf(5000000000L + random.nextInt(999999999));
            String new_mtn = String.valueOf(5000000000L + random.nextInt(999999999));

            String sql = String.format("UPDATE %s SET selected_MTN = '%s', mtn = '%s' WHERE cust_id = '%s';",
                    tableName, new_selected_MTN, new_mtn, cust_id);
            updateStatements.add(sql);
        }
        return updateStatements;
    }

    private static List<String> generateDeleteStatements(String tableName, List<String> inserts, int count) {
        Random random = new Random();
        List<String> deleteStatements = new ArrayList<>();
        List<String> randomInserts = new ArrayList<>(inserts.subList(0, count));

        for (String insert : randomInserts) {
            String cust_id = extractCustIdFromInsert(insert);
            String sql = String.format("DELETE FROM %s WHERE cust_id = '%s';", tableName, cust_id);
            deleteStatements.add(sql);
        }
        return deleteStatements;
    }

    private static String extractCustIdFromInsert(String insertStatement) {
        return insertStatement.split("'")[1];
    }
}


import com.google.cloud.spanner.DatabaseClient;
import com.google.cloud.spanner.Mutation;
import com.google.cloud.spanner.Spanner;
import com.google.cloud.spanner.SpannerOptions;
import org.apache.beam.sdk.Pipeline;
import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;
import org.apache.beam.sdk.transforms.DoFn;
import org.apache.beam.sdk.transforms.ParDo;
import org.apache.beam.sdk.values.PCollection;

public class PubSubToSpanner {

    public static void main(String[] args) {
        Pipeline pipeline = Pipeline.create();

        // Read messages from Pub/Sub subscription
        String subscription = "projects/your-project-id/subscriptions/your-subscription-id";
        PCollection<String> pubSubMessages = pipeline.apply("ReadFromPubSub",
                PubsubIO.readStrings().fromSubscription(subscription));

        // Process and write to Spanner
        pubSubMessages.apply("ProcessMessages", ParDo.of(new ProcessPubSubMessageFn()));

        pipeline.run().waitUntilFinish();
    }

    static class ProcessPubSubMessageFn extends DoFn<String, Void> {
        private transient Spanner spanner;
        private transient DatabaseClient dbClient;

        @Setup
        public void setup() {
            // Initialize Spanner connection
            SpannerOptions options = SpannerOptions.newBuilder().build();
            spanner = options.getService();
            dbClient = spanner.getDatabaseClient(
                    SpannerOptions.getDefaultProjectId(),
                    "your-instance-id",
                    "your-database-id"
            );
        }

        @ProcessElement
        public void processElement(ProcessContext context) {
            String sqlStatement = context.element();
            // Handle INSERT/UPDATE/DELETE based on the SQL message
            Mutation mutation = Mutation.newInsertOrUpdateBuilder("YourTableName")
                    .set("your_column_name").to("some_value")  // parse sqlStatement to build the Mutation
                    .build();

            // Submit the mutation to Spanner
            dbClient.write(List.of(mutation));
        }

        @Teardown
        public void teardown() {
            // Close Spanner connection
            if (spanner != null) {
                spanner.close();
            }
        }
    }
}




import com.google.cloud.spanner.DatabaseClient;
import com.google.cloud.spanner.DatabaseId;
import com.google.cloud.spanner.Spanner;
import com.google.cloud.spanner.SpannerOptions;

public class SpannerExample {
    public static void main(String[] args) {
        // Initialize Spanner
        SpannerOptions options = SpannerOptions.newBuilder().build();
        Spanner spanner = options.getService();

        // Define the project ID, instance ID, and database ID
        String projectId = options.getProjectId();
        String instanceId = "your-instance-id";
        String databaseId = "your-database-id";

        // Create a DatabaseId object
        DatabaseId db = DatabaseId.of(projectId, instanceId, databaseId);

        // Get the database client using the DatabaseId object
        DatabaseClient dbClient = spanner.getDatabaseClient(db);

        // Now dbClient is ready to interact with Spanner
        System.out.println("Connected to Spanner database: " + db);
    }
}





import com.google.cloud.spanner.DatabaseClient;
import com.google.cloud.spanner.Spanner;
import com.google.cloud.spanner.SpannerOptions;
import com.google.cloud.spanner.TransactionContext;
import com.google.cloud.spanner.TransactionRunner.TransactionCallable;
import org.apache.beam.sdk.Pipeline;
import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;
import org.apache.beam.sdk.transforms.DoFn;
import org.apache.beam.sdk.transforms.ParDo;
import org.apache.beam.sdk.values.PCollection;

public class PubSubToSpanner {

    public static void main(String[] args) {
        Pipeline pipeline = Pipeline.create();

        // Read messages from Pub/Sub subscription
        String subscription = "projects/your-project-id/subscriptions/your-subscription-id";
        PCollection<String> pubSubMessages = pipeline.apply("ReadFromPubSub",
                PubsubIO.readStrings().fromSubscription(subscription));

        // Process and write to Spanner
        pubSubMessages.apply("ProcessMessages", ParDo.of(new ProcessPubSubMessageFn()));

        pipeline.run().waitUntilFinish();
    }

    static class ProcessPubSubMessageFn extends DoFn<String, Void> {
        private transient Spanner spanner;
        private transient DatabaseClient dbClient;

        @Setup
        public void setup() {
            // Initialize Spanner connection
            SpannerOptions options = SpannerOptions.newBuilder().build();
            spanner = options.getService();

            // Set up Spanner Database Client
            String instanceId = "your-instance-id";
            String databaseId = "your-database-id";
            dbClient = spanner.getDatabaseClient(
                SpannerOptions.getDefaultProjectId(),
                instanceId,
                databaseId
            );
        }

        @ProcessElement
        public void processElement(ProcessContext context) {
            String sqlStatement = context.element();

            // Submit SQL statement directly to Spanner within a transaction
            dbClient.runTransaction((TransactionCallable<Void>) transaction -> {
                try {
                    transaction.executeUpdate(com.google.cloud.spanner.Statement.of(sqlStatement));
                } catch (Exception e) {
                    System.err.println("Failed to execute SQL: " + sqlStatement);
                    e.printStackTrace();
                }
                return null;  // Return null because no value is needed
            });
        }

        @Teardown
        public void teardown() {
            // Close Spanner connection
            if (spanner != null) {
                spanner.close();
            }
        }
    }
}

